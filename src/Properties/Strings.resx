<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Activation_AmbiguousExplicitFeatureActivator" xml:space="preserve">
    <value>There are multiple types implemented IFeatureActivator interface and the FeatureId returns the same value "{0}" in the assembly {1}.</value>
  </data>
  <data name="Activation_AmbiguousImplictFeatureActivator" xml:space="preserve">
    <value>There are multiple types implemented IFeatureActivator interface without FeatureId in the assembly {0}. The application cannot determine which one should be used.</value>
  </data>
  <data name="Activation_CannotFindParameter" xml:space="preserve">
    <value>The parameter {0} of the method {1} declared in the type {2} has not been registered.</value>
  </data>
  <data name="Activation_CannotGenericMethod" xml:space="preserve">
    <value>The method {0} in the type {1} cannot be generic.</value>
  </data>
  <data name="Activation_CannotLoadFeatureEntry" xml:space="preserve">
    <value>The entry assembly of the feature {1} cannot be loaded: {0}.</value>
  </data>
  <data name="Activation_CannotLoadModuleEntry" xml:space="preserve">
    <value>The entry assembly of the module {1} cannot be loaded: {0}.</value>
  </data>
  <data name="Activation_CannotMultipleMethod" xml:space="preserve">
    <value>There are multiple public method {0} have been found in the type {1}. The application cannot determine which one should be used to invoke.</value>
  </data>
  <data name="Activation_CircleDependency" xml:space="preserve">
    <value>The circle dependency has been detected for the features: {0}.</value>
  </data>
  <data name="Activation_DuplicateFeatures" xml:space="preserve">
    <value>There are multiple features with the same ID: {0}.</value>
  </data>
  <data name="Activation_DuplicateModules" xml:space="preserve">
    <value>There are multiple modules with the same ID: {0}.</value>
  </data>
  <data name="Activation_InvalidParameter" xml:space="preserve">
    <value>The parameter {0} of the method {1} declared in the type {2} cannot be out or ref.</value>
  </data>
  <data name="Activation_PropertyCannotBeIndexer" xml:space="preserve">
    <value>The property {0} declared in the type {1} cannot have index parameters.</value>
  </data>
  <data name="Activation_PropertyMustCanRead" xml:space="preserve">
    <value>The property {0} declared in the type {1} does not have getter method.</value>
  </data>
  <data name="Activation_PropertyMustReturnString" xml:space="preserve">
    <value>The return value of property {0} declared in the type {1} must be string.</value>
  </data>
  <data name="Argument_Cannot_Be_Null_Or_Empty" xml:space="preserve">
    <value>Value cannot be null or an empty string.</value>
  </data>
  <data name="Collection_ReadOnly" xml:space="preserve">
    <value>The collection is read only.</value>
  </data>
  <data name="Configuration_ReadOnly" xml:space="preserve">
    <value>The module configuration is read-only, since the module container has been started.</value>
  </data>
  <data name="Container_NotStart" xml:space="preserve">
    <value>The module container has not been started.</value>
  </data>
  <data name="Container_StartAgain" xml:space="preserve">
    <value>The module container has been started, and cannot be started again.</value>
  </data>
  <data name="Container_Started" xml:space="preserve">
    <value>The module container has been started, and the configuration cannot be changed.</value>
  </data>
  <data name="Discover_AmbiguousFeatureEntry" xml:space="preserve">
    <value>Ambiguous assemblies have been found for the entry assembly of the feature {0}.</value>
  </data>
  <data name="Discover_AmbiguousModuleEntry" xml:space="preserve">
    <value>Ambiguous assemblies have been found for the entry assembly of the module {0}.</value>
  </data>
  <data name="Discover_CannotFindFeatureEntry" xml:space="preserve">
    <value>The entry assembly for the feature {0} cannot be found: {1}</value>
  </data>
  <data name="Discover_CannotFindModuleEntry" xml:space="preserve">
    <value>The entry assembly for the module {0} cannot be found: {1}</value>
  </data>
  <data name="Invalid_Dependency" xml:space="preserve">
    <value>'{0}' is not a valid dependency string.</value>
  </data>
  <data name="Locator_InvalidJsonToken" xml:space="preserve">
    <value>The json token {0} is not supported in the file {1}.</value>
  </data>
  <data name="Locator_InvalidTextLine" xml:space="preserve">
    <value>The format is invalid at line {0} in the file {1}.</value>
  </data>
  <data name="Manifest_InvalidDependency" xml:space="preserve">
    <value>'{0}' is not a valid dependency in the manifest file of the module {1}.</value>
  </data>
  <data name="Manifest_InvalidDependencyVersion" xml:space="preserve">
    <value>'{0}' is not a valid dependency version in the manifest file of the module {1}.</value>
  </data>
  <data name="Manifest_InvalidFormat" xml:space="preserve">
    <value>The format of {0} is invalid in the manifest file of the module {1}.</value>
  </data>
  <data name="Manifest_InvalidJsonToken" xml:space="preserve">
    <value>The json token {0} is not supported in the manifest file of the module {1}.</value>
  </data>
  <data name="Manifest_InvalidTextLine" xml:space="preserve">
    <value>The format is invalid at line {0} in the manifest file of the module {1}.</value>
  </data>
  <data name="Manifest_NoElement" xml:space="preserve">
    <value>The manifest does not defined any elements for the module {0}.</value>
  </data>
</root>